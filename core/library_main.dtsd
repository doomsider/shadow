#!/bin/bash
# Shadow .01 Based off of DTSD
# Main library for all DTSD related functions

DTSDHELP_restart="\nRestart usage: shadow.dtsd restart\nSoft restart for server.  For a hard reset\n"

lib_arraycontains() {
    [[ -n "$1" && -n "$2" ]] || {
        echo "usage: lib_arraycontains <array> <value>"
        echo "Returns 0 if array contains value, 1 otherwise"
        return 2
    }
    eval 'local values=("${'$1'[@]}")'
    local element
    for element in "${values[@]}"; do
        [[ "$element" == "$2" ]] && return 0
    done
    return 1
}

lib_check_server_running() {
#Special thanks to tschaerni for a simplified search here
if pgrep -a java | grep $CONFIGDTSD_SERVICE | grep port:$CONFIGDTSD_PORT > /dev/null
then
SERVERSTATUS=STOPPED
return 0
else
SERVERSTATUS=RUNNING
return 1 
fi
}


lib_searchline() {
# Usage lib_searchline line
# This generates an array of all the search strings and then tests them against a line from the log
	SEARCHVAR=( $(compgen -v | grep LOGSEARCH_ ) )
	SEARCHARRAY=0
	while [ -n "${SEARCHVAR[$SEARCHARRAY]+set}" ]
	do
		CURRENTSEARCH=${SEARCHVAR[$SEARCHARRAY]}
		SEARCHSTRING=${!CURRENTSEARCH}
		SEARCHFUNCTION=${CURRENTSEARCH#*_}
		SEARCHCOMMAND="${@:1}"
#		echo "here is the search command $SEARCHCOMMAND"
		case "$SEARCHCOMMAND" in 
		*"$SEARCHSTRING"*)   
			echo "match found"
			eval $SEARCHFUNCTION '$SEARCHCOMMAND' &
# Not sure if there should be a break here, may save some time after a match has been found
		;;
		esac
#	echo "Search function is $SEARCHFUNCTION"
#	echo "Search string is ${!CURRENTSEARCH}"
		let SEARCHARRAY++
	done
}

core_sortsearch () {
# Temporary core function to test a string against current searches
	SORTSTRING="${@:2}"
	lib_searchline $SORTSTRING
}


lib_screenadd() {
#usage lib_screenadd screenname
	if ps aux | grep -v grep | grep SCREEN | grep $1 >/dev/null
    then
		echo "Screen(s) identified by $1 detected and will be closed"
		PIDS=( $(ps aux | grep -v grep | grep SCREEN | grep $1 | awk '{print $2}') )   
		echo "Trying to kill these ${PIDS[@]}"		
		kill ${PIDS[@]}
	fi
	echo "starting screen $1"
	screen -dmS $1
}

core_screenadd() {
# Temporary core function 
	echo "attempting to create screen $2"
	lib_screenadd $2
}

lib_screensend() {
# usage lib_screensend screen command
	STUFFCOMMAND="${@:2}"
	echo "trying to send this command $STUFFCOMMAND to the screen $1"
	screen -p 0 -S $1 -X stuff "$STUFFCOMMAND"$(printf \\r)
}

core_screensend() {
# Temporary core function 
	STUFFCOMMAND="${@:3}"
	echo "Sending command"
	lib_screensend $2 $STUFFCOMMAND
}

lib_screensendback() {
# usage lib_screensendback screen command
	STUFFCOMMAND="${@:2}"
	echo "trying to send this command $STUFFCOMMAND to the screen $1"
	screen -p 0 -S $1 -X stuff "$STUFFCOMMAND &"$(printf \\r)
}

core_screensendback() {
# Temporary core function 
	STUFFCOMMAND="${@:3}"
	echo "Sending command"
	lib_screensendback $2 $STUFFCOMMAND
}


core_do() {
STUFFCOMMAND="${@:2}"
echo "Sending command"
lib_screensend $CONFIGDTSD_MAINSCREEN $STUFFCOMMAND

}

lib_pause() {
  local dummy
  read -s -r -p "Press any key to continue..." -n 1 dummy
}

core_softstart() {
# Softstart can only be ran after a softstop
	if ps aux | grep -v grep | grep SCREEN | grep $CONFIGDTSD_DTSDSCREEN >/dev/null
    then
		echo "Screen(s) identified by $CONFIGDTSD_DTSDSCREEN detected and will be closed"
		PIDS=( $(ps aux | grep -v grep | grep SCREEN | grep $CONFIGDTSD_DTSDSCREEN | awk '{print $2}') )   
	echo "Trying to kill these ${PIDS[@]}"		
	kill ${PIDS[@]}
	fi
	lib_screenadd $CONFIGDTSD_DTSDSCREEN
	echo "re-starting server"
	if lib_check_server_running
	#	if ps aux | grep $CONFIGDTSD_SERVICE | grep -v grep | grep -v tee | grep port:$CONFIGDTSD_PORT  >/dev/null
	then
		echo "Tried to start but $CONFIGDTSD_SERVICE was already running!"
	else
		echo "$CONFIGDTSD_SERVICE was not running... starting."	
# For java to launch Starmade it must be launched in the correct directory
		lib_screensend $CONFIGDTSD_MAINSCREEN cd $CONFIGDTSD_INSTALLPATH/StarMade
# Start script which will create a shell that is logged for all output.  This is useful to see the commands that are given.
# -f is used to flush data as it is given and keeps the log file updated quickly
		lib_screensend $CONFIGDTSD_MAINSCREEN script -f $CONFIGDTSD_INSTALLPATH/CONFIGDTSD_MAINSCREEN.log
		lib_screensend $CONFIGDTSD_DTSDSCREEN script -f $CONFIGDTSD_INSTALLPATH/CONFIGDTSD_SCRIPTSCREEN.log
		lib_screensend $CONFIGDTSD_MAINSCREEN java -Xmx$CONFIGDTSD_MAXMEM -Xms$CONFIGDTSD_MINMEM -jar $CONFIGDTSD_SERVICE -server -port:$CONFIGDTSD_PORT
# 	lib_screensend $CONFIGDTSD_MAINSCREEN java -Xmx$CONFIGDTSD_MAXMEM -Xms$CONFIGDTSD_MINMEM -jar "$CONFIGDTSD_INSTALLPATH"StarMade/$CONFIGDTSD_SERVICE -server -port:$CONFIGDTSD_PORT

# Backgrounding runlog is disabled in testing so you can stop it and restart it from the dtsdscreen with logcollect
#		lib_screensendback $CONFIGDTSD_DTSDSCREEN $CONFIGDTSD_SCRIPTPATH logcollect
#		lib_screensend $CONFIGDTSD_DTSDSCREEN $CONFIGDTSD_SCRIPTPATH mycreate
#		lib_screensend $CONFIGDTSD_DTSDSCREEN $CONFIGDTSD_SCRIPTPATH setranks
		lib_screensend $CONFIGDTSD_DTSDSCREEN $CONFIGDTSD_SCRIPTPATH logcollect
	fi  

}

core_softstop() {
# Restarts the server without killing all the screens at once
	if lib_check_server_running
	then
		echo "$SERVICE is running... stopping."
# Issue Chat and a command to the server to shutdown
		lib_screensend $CONFIGDTSD_MAINSCREEN "/chat Server Going down be back in a bit."
		lib_screensend $CONFIGDTSD_MAINSCREEN "/shutdown 60"
# Give the server a chance to gracefully shutdown if not kill it and then seg fault it if necessary
		sleep 60
		for LOOPNO in {0..30}
		do
			if lib_check_server_running
			then
				sleep 1
			else
				echo $CONFIGDTSD_SERVICE took $LOOPNO seconds to close
		break
			fi
		done
		if lib_check_server_running
		then
			echo $CONFIGDTSD_SERVICE is taking too long to close and may be frozen. Forcing shut down
			PID=$(ps aux | grep -v grep | grep $CONFIGDTSD_SERVICE | grep -v tee | grep port:$CONFIGDTSD_PORT | awk '{print $2}')
			kill $PID
			for LOOPNO in {0..30}
			do
				if lib_check_server_running
				then
					sleep 1
				else
					echo $CONFIGDTSD_SERVICE took $(($LOOPNO + 30)) seconds to close, and had to be force shut down
			break
				fi
			done
		fi
		if lib_check_server_running 
		then
			PID=$(ps aux | grep -v grep | grep $CONFIGDTSD_SERVICE | grep -v tee | grep port:$CONFIGDTSD_PORT | awk '{print $2}')
			kill -9 $PID			
			$CONFIGDTSD_SERVICE took too long to close. $CONFIGDTSD_SERVICE had to be killed
		fi
	else
		echo "$CONFIGDTSD_SERVICE not running"
	fi
# Stop the running log collect so it can be restarted
	if ps aux | grep -v grep | grep SCREEN | grep $CONFIGDTSD_MAINSCREEN >/dev/null
    then
		echo "Screen(s) identified by $CONFIGDTSD_MAINSCREEN detected and will be closed"
		PIDS=( $(ps aux | grep -v grep | grep SCREEN | grep $CONFIGDTSD_MAINSCREEN | awk '{print $2}') )   
		echo "Trying to kill these ${PIDS[@]}"		
		kill ${PIDS[@]}
	fi
	lib_screenadd $CONFIGDTSD_MAINSCREEN
	lib_screensend $CONFIGDTSD_MAINSCREEN $CONFIGDTSD_SCRIPTPATH softstart
	
}


#function_exists(){
#	if declare -f -F $1 > /dev/null 2>&1
#	then
#		return 0
#	else 
#		return 1
#	fi
#
#FUNCTIONEXISTS=$?
#}

# Create an array with the indirect reference of the current rankcommand and the values command list contains
#	eval COMMANDLIST=\( \${${CURRENTARRAY}[@]} \)

#Temporary holding spot for search strings, these will be placed in their respective functions
#	SEARCHLOGIN="[SERVER][LOGIN] login received. returning login info for RegisteredClient: "
#		SEARCHREMOVE="[SERVER][DISCONNECT] Client 'RegisteredClient:"
#		SEARCHCHAT="[CHAT]"
#		SEARCHCHANGE="has players attached. Doing Sector Change for PlS"
#		SEARCHBUY="[BLUEPRINT][BUY]"
#		SEARCHBOARD="[CONTROLLER][ADD-UNIT]"
#		SEARCHDOCK="NOW REQUESTING DOCK FROM"
#		SEARCHUNDOCK="NOW UNDOCKING:"
#		SEARCHADMIN="[ADMIN COMMAND]"
#		SEARCHKILL="Announcing kill:"
#		SEARCHDESTROY="PERMANENTLY DELETING ENTITY:"
#		SEARCHINIT="SPAWNING NEW CHARACTER FOR PlS"