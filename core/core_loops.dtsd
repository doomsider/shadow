#!/bin/bash
# Shadow .01 Based off of DTSD
# Script that follows the log and feeds the log into the search functions and database

MYSQLDTSD_SERVERLOG_LOGSTRING="TEXT NOT NULL"
MYSQLDTSD_SERVERLOG_LOGDATE=TIMESTAMP

MYSQLDTSD_log_LOGSTRING="VARCHAR(256) NOT NULL"
MYSQLDTSD_log_LOGDATE=TIMESTAMP
MYSQLALTER_log_LOGSTRING="UNIQUE INDEX"

MYSQLDTSD_COMMANDDB_LOGDATE=TIMESTAMP
MYSQLDTSD_COMMANDDB_PARAMETER="TEXT NOT NULL"
MYSQLDTSD_COMMANDDB_COMMAND="TEXT NOT NULL"

MYSQLDTSD_SEARCHDB_SEARCHSTRING="VARCHAR(255)"
MYSQLDTSD_SEARCHDB_SEARCHFUNCTION="VARCHAR(50)"

DTSDDEFAULTVALUE_USERAMDRIVE=no

# The current logging script works by feeding the current starmade log into the database and then searching the database to find matches with search
# strings and their associated functions
core_logloop() {
	if [ "$USERAMDRIVE" = "no" ]
	then
		WRITEDIR=$CONFIGDTSD_INSTALLPATH
	else
		WRITEDIR="/dev/shm"
	fi
# This function is testing a solution to the sluggishness of the current_core loop.  Currently it inserts lines into the database while they are received from a log file.
	log_myerasetable SERVERLOG
	log_myerasetable TRIGGERDB
	log_myerasetable COMMANDDB
	log_myerasetable DUEL
	MYSQLSTART=0
	sleep 5
	while true
	do
		LOGACTIVE=false
		NUMOFLINES=$(wc -l $CONFIGDTSD_INSTALLPATH/StarMade/logs/logstarmade.0.log | cut -d" " -f1) 
# In case Linestart does not have a value give it an integer value of 1.  The prevents a startup error on the script.
		if [ -z "$LINESTART" ]
		then
			LINESTART=$NUMOFLINES
			#echo "Start at line $LINESTART"
		fi
# Since the Starmade log file rolls after 4mb the Linestart must be reset back to something reasonable when this happens or the script will hang. Special thanks to LordDragon for helping trouble shoot this
		if [ "$LINESTART" -gt "$NUMOFLINES" ]
		then
			echo "Log file for $CONFIGDTSD_SERVICE has been reset or rolled over"
			LINESTART=$NUMOFLINES
		fi
# If the number of lines read from the log file is greater than last line read + 1 from the log then feed more lines.
		if [ "$NUMOFLINES" -gt "$LINESTART" ] 
		then
			LOGACTIVE=true
			#echo "$NUMOFLINES is the total lines of the log"
			#echo "$LINESTART is linestart"
			let LINESTART++
# Use sed to gather the current selection of lines
			sed -n "$LINESTART,$NUMOFLINES p" $CONFIGDTSD_INSTALLPATH/StarMade/logs/logstarmade.0.log > $WRITEDIR/SERVERLOG.txt
# Remove any quotes from the log to prevent processing issues in mysql
			sed -i 's/\"//g' $WRITEDIR/SERVERLOG.txt
# Mysqlimport is a command line version of load data infile and rapidly inserts a file into Mysql
			mysqlimport --user=$CONFIGDTSD_MYSQLUSER --password=$CONFIGDTSD_MYSQLPASS --columns=LOGSTRING --fields-terminated-by='\n' --silent --local $DTSDDB $WRITEDIR/SERVERLOG.txt
# Get the last line of the MYSQL table Serverlog where th log is being dumped
			MYSQLSTOP=$(mysql --defaults-extra-file=$CONFIGDTSD_INSTALLPATH/core/shadow.cnf -sNe "SELECT line FROM SERVERLOG ORDER BY line DESC LIMIT 1;")
			#echo "MYSQLSTOP $MYSQLSTOP"
			#echo "MYSQLSTART $MYSQLSTART"
			let MYSQLSTART++
# Search through the log from the last mysqlstart and the current mysqlstop and insert any matched into the Commanddb
			mysql --defaults-extra-file=$CONFIGDTSD_INSTALLPATH/core/shadow.cnf -e  "INSERT INTO COMMANDDB (PARAMETER, COMMAND) SELECT SERVERLOG.LOGSTRING, SEARCHDB.SEARCHFUNCTION FROM SERVERLOG, SEARCHDB WHERE LOCATE(SEARCHDB.SEARCHSTRING, SERVERLOG.LOGSTRING) > 0 AND SERVERLOG.line <= $MYSQLSTOP AND SERVERLOG.line >= $MYSQLSTART ORDER BY SERVERLOG.line ASC;"
			LINESTART=$NUMOFLINES
			let MYSQLSTART=$MYSQLSTOP
		fi
# Quick check to save Mysql time to see if commands are in the Commanddb
		CHECKCOMMANDS=$(mysql --defaults-extra-file=$CONFIGDTSD_INSTALLPATH/core/shadow.cnf -sNe "SELECT 1 FROM COMMANDDB LIMIT 1;")
		if [ -n "${CHECKCOMMANDS-unset}" ]
		then
#		echo "CHECKCOMMANDS $CHECKCOMMANDS"
#		echo "commands detected"
# Set the field seperator to newline so commands and parameters are received as a single array variable and not broken up by the normal space field seperator
			OLD_IFS=$IFS
			IFS=$'\n'
# Gather command and parameter
			RECIEVEDCOMMAND=( $(mysql --defaults-extra-file=$CONFIGDTSD_INSTALLPATH/core/shadow.cnf -sNe "select COMMAND from COMMANDDB order by line asc;") )
			RECIEVEDPARAMETER=( $(mysql --defaults-extra-file=$CONFIGDTSD_INSTALLPATH/core/shadow.cnf -sNe "select PARAMETER from COMMANDDB order by line asc;") )
# Reset the field seperator so it does not cause issues with the rest of the execution of the script
			IFS=$OLD_IFS
# Reset the database so the same command is not read repeatedly 
			mysql --defaults-extra-file=$CONFIGDTSD_INSTALLPATH/core/shadow.cnf -e "truncate table COMMANDDB;"
			POSITIONCOMMANDARRAY=0
			PARAMETERARRAY=0
# Go through each command and parameter received and execute them with eval
			while [ -n "${RECIEVEDCOMMAND[$POSITIONCOMMANDARRAY]+set}" ]
			do
				RECIEVEDCOMMAND=${RECIEVEDCOMMAND[$POSITIONCOMMANDARRAY]}
				RECIEVEDPARAMETER=${RECIEVEDPARAMETER[$PARAMETERARRAY]}
				#echo "executing $RECIEVEDCOMMAND $RECIEVEDPARAMETER"
				$RECIEVEDCOMMAND ${RECIEVEDPARAMETER}
				let POSITIONCOMMANDARRAY++
				let PARAMETERARRAY++
			done
		fi
	if [ "$LOGACTIVE" = "false" ]
	then
		sleep 0.5
	fi
	done
}
# Trap is used here to restart logloop if it exits due to a bad call
# trap core_logloop EXIT
core_makesearchdb() {
# Make the search database which contains all the search strings and their related functions
	log_myerasetable SEARCHDB
	SEARCHVAR=( $(compgen -v | grep LOGSEARCH_ ) )
	SEARCHARRAY=0
	while [ -n "${SEARCHVAR[$SEARCHARRAY]+set}" ]
	do
		CURRENTSEARCH=${SEARCHVAR[$SEARCHARRAY]}
		CURRENTSEARCHSTRING=${!CURRENTSEARCH}
		CURRENTSEARCHFUNCTION=${CURRENTSEARCH#*_}
		lib_myinsert SEARCHDB SEARCHFUNCTION "$CURRENTSEARCHFUNCTION"
		lib_myupdate SEARCHDB SEARCHSTRING "$CURRENTSEARCHSTRING" SEARCHFUNCTION $CURRENTSEARCHFUNCTION
		let SEARCHARRAY++
	done
}

########################OLD FUNCTIONS########################

core_loadlog() {
# This function is testing a solution to the sluggishness of the tailog function.  Currently it used Mysqlimport to rapidly insert lines into a table with a unique column.  This way the file can be loaded into the database again and again without adding duplicate lines.

	log_myerasetable log
	while lib_check_server_running
	do 
		 mysqlimport --user=$CONFIGDTSD_MYSQLUSER --password=$CONFIGDTSD_MYSQLPASS --columns=LOGSTRING --fields-terminated-by='\n' --silent --local dtsddb $CONFIGDTSD_INSTALLPATH/StarMade/logs/logstarmade.0.log
# Sleep added here to keep it from burning up the CPU.  This value can be modified based upon how aggressive you want the script to run.
		 sleep 1
	done
}

core_taillog() {
	log_myerasetable SERVERLOG
# Tail with -F to prevent rollover file from stopping read is extremely fast and lightweight method for feeding log lines into the database
	tail -F $CONFIGDTSD_INSTALLPATH/StarMade/logs/logstarmade.0.log |
    while read a; do
# Quotations will cause Mysql to error so they are removed with a in line edit 
		STRING=${a//\"/}
#		echo "INSERT INTO SERVERLOG LOGSTRING $STRING"
		mysql --defaults-extra-file=$CONFIGDTSD_INSTALLPATH/core/shadow.cnf -e "INSERT INTO SERVERLOG (LOGSTRING) VALUES (\"$STRING\");"
    done
}
core_search_executelog() {
	log_myerasetable TRIGGERDB
	log_myerasetable COMMANDDB
	while true
	do 
		NUMOFLINES=$(mysql --defaults-extra-file=$CONFIGDTSD_INSTALLPATH/core/shadow.cnf -sNe "SELECT line FROM log ORDER BY line DESC LIMIT 1;")
		#echo "Here is the last line of the log $NUMOFLINES"
		# if the number of lines isn't detected it is because no lines have been fed yet
		if [ -z "$NUMOFLINES" ]
		then
			NUMOFLINES=0
#			echo "Setting numoflines to 0"
		fi
		if [ -z "$LINESTART" ]
		then
			LINESTART=$NUMOFLINES
#			echo "Start at line $LINESTART"
		fi
		if [ "$NUMOFLINES" -gt "$LINESTART" ] 
		then
#			echo "$NUMOFLINES is the total lines of the log"
#			echo "$LINESTART is linestart"
			let LINESTART++
			mysql --defaults-extra-file=$CONFIGDTSD_INSTALLPATH/core/shadow.cnf -e  "INSERT INTO COMMANDDB (PARAMETER, COMMAND) SELECT log.LOGSTRING, SEARCHDB.SEARCHFUNCTION FROM log, SEARCHDB WHERE LOCATE(SEARCHDB.SEARCHSTRING, log.LOGSTRING) > 0 AND log.line <= $NUMOFLINES AND log.line >= $LINESTART ORDER BY log.line ASC"
			LINESTART=$NUMOFLINES
		fi
		OLD_IFS=$IFS
		IFS=$'\n'
		RECIEVEDCOMMAND=( $(mysql --defaults-extra-file=$CONFIGDTSD_INSTALLPATH/core/shadow.cnf -sNe "select COMMAND from COMMANDDB order by line asc;") )
		RECIEVEDPARAMETER=( $(mysql --defaults-extra-file=$CONFIGDTSD_INSTALLPATH/core/shadow.cnf -sNe "select PARAMETER from COMMANDDB order by line asc;") )
		mysql --defaults-extra-file=$CONFIGDTSD_INSTALLPATH/core/shadow.cnf -e "truncate table COMMANDDB;"
		IFS=$OLD_IFS
		COMMANDARRAY=0
		PARAMETERARRAY=0
		while [ -n "${RECIEVEDCOMMAND[$COMMANDARRAY]+set}" ]
		do
			RECIEVEDCOMMAND=${RECIEVEDCOMMAND[$COMMANDARRAY]}
			RECIEVEDPARAMETER=${RECIEVEDPARAMETER[$PARAMETERARRAY]}
			echo "executing $RECIEVEDCOMMAND $RECIEVEDPARAMETER"
			eval $RECIEVEDCOMMAND '$RECIEVEDPARAMETER'
			let COMMANDARRAY++
			let PARAMETERARRAY++
		done
		sleep 1
	done
}

