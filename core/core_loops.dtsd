#!/bin/bash
# Shadow .01 Based off of DTSD
# Script that follows the log and feeds the log into the search functions and database

MYSQLDTSD_SERVERLOG_LOGSTRING="TEXT NOT NULL"
MYSQLDTSD_SERVERLOG_LOGDATE=TIMESTAMP

MYSQLDTSD_COMMANDDB_LOGDATE=TIMESTAMP
MYSQLDTSD_COMMANDDB_PARAMETER="TEXT NOT NULL"
MYSQLDTSD_COMMANDDB_COMMAND="TEXT NOT NULL"

MYSQLDTSD_SEARCHDB_SEARCHSTRING="VARCHAR(255)"
MYSQLDTSD_SEARCHDB_SEARCHFUNCTION="VARCHAR(50)"

# The current logging script works by feeding the current starmade log into the database and then searching the database to find matches with search
# strings and their associated functions
ONSTART_RUN() {
	lib_screensend $CONFIGDTSD_DTSDSCREEN $CONFIGDTSD_SCRIPTPATH mycreate
	lib_screensend $CONFIGDTSD_DTSDSCREEN $CONFIGDTSD_SCRIPTPATH setranks
	lib_screensend $CONFIGDTSD_DTSDSCREEN $CONFIGDTSD_SCRIPTPATH makesearchdb
	lib_screensendback $CONFIGDTSD_DTSDSCREEN $CONFIGDTSD_SCRIPTPATH taillog
	lib_screensendback $CONFIGDTSD_DTSDSCREEN $CONFIGDTSD_SCRIPTPATH searchlog
	lib_screensend $CONFIGDTSD_DTSDSCREEN $CONFIGDTSD_SCRIPTPATH executelog
}
ONINTERVAL_600_announce() {
	lib_screensend $CONFIGDTSD_MAINSCREEN "/chat This message brought to you by Shadow pre-alpha"
}
ONEND_goodbye() {
echo "Server stopped"
}
core_mainloop() {
    ONSTART=( $(compgen -A function | grep ONSTART_) )
    ONINTERVAL=( $(compgen -A function | grep ONINTERVAL_) )
    ONEND=( $(compgen -A function | grep ONEND_) )
    for func in ${ONSTART[@]}
    do
        $func &
    done
    curtime=0
	while lib_check_server_running
	do
		for func in ${ONINTERVAL[@]}
		do
			#echo "Checking on interval functions"
# the % operator returns the remainder of a division. when this remainder is 0, that means the time is a while multiple of the interval
# meaning the function should be ran
			if [ $(( curtime%$(($(echo $func | cut -d"_" -f2))))) -eq 0 ]
			then
				echo "executing interval function $func" 
				$func &
			fi
		done
		let curtime++
		#echo "started loop"
# A tiny sleep to prevent cpu burning overhead
		sleep 1
# Uses Cat to calculate the number of lines in the log file
	done
	for func in ${ONEND[@]}
	do
		$func &
	done
}
core_taillog() {
# Tail with -F to prevent rollover file from stopping read is extremely fast and lightweight method for feeding log lines into the database
	tail -F $CONFIGDTSD_INSTALLPATH/StarMade/logs/log.txt.0 |
    while read a; do
# Quotations will cause Mysql to error so they are removed with a in line edit 
		STRING=$(sed "s/\"//g" <<< "$a")
#		echo "INSERT INTO SERVERLOG LOGSTRING $STRING"
		mysql -D $CONFIGDTSD_MYSQLDB -u $CONFIGDTSD_MYSQLUSER -p$CONFIGDTSD_MYSQLPASS -e "INSERT INTO SERVERLOG (LOGSTRING) VALUES (\"$STRING\");"
    done
}
core_searchlog() {
	log_myerasetable SERVERLOG
	log_myerasetable TRIGGERDB
	log_myerasetable COMMANDDB
	while lib_check_server_running
	do 
		# mysql -D $CONFIGDTSD_MYSQLDB -u $CONFIGDTSD_MYSQLUSER -p$CONFIGDTSD_MYSQLPASS -sNe "SELECT line FROM SERVERLOG ORDER BY line DESC LIMIT 1;"
		NUMOFLINES=$(mysql -D $CONFIGDTSD_MYSQLDB -u $CONFIGDTSD_MYSQLUSER -p$CONFIGDTSD_MYSQLPASS -sNe "SELECT line FROM SERVERLOG ORDER BY line DESC LIMIT 1;")
		#echo "Here is the last line of the log $NUMOFLINES"
		# if the number of lines isn't detected it is because no lines have been fed yet
		if [ -z "$NUMOFLINES" ]
		then
			NUMOFLINES=0
#			echo "Setting numoflines to 0"
		fi
		if [ -z "$LINESTART" ]
		then
			LINESTART=$NUMOFLINES
#			echo "Start at line $LINESTART"
		fi
		LOGACTIVE=NO
		if [ "$NUMOFLINES" -gt "$LINESTART" ] 
		then
#			echo "$NUMOFLINES is the total lines of the log"
#			echo "$LINESTART is linestart"
			let LINESTART++
			mysql -D $CONFIGDTSD_MYSQLDB -u $CONFIGDTSD_MYSQLUSER -p$CONFIGDTSD_MYSQLPASS -e  "INSERT INTO COMMANDDB (PARAMETER, COMMAND) SELECT SERVERLOG.LOGSTRING, SEARCHDB.SEARCHFUNCTION FROM SERVERLOG, SEARCHDB WHERE LOCATE(SEARCHDB.SEARCHSTRING, SERVERLOG.LOGSTRING) > 0 AND SERVERLOG.line <= $NUMOFLINES AND SERVERLOG.line >= $LINESTART ORDER BY SERVERLOG.line ASC"
			LINESTART=$NUMOFLINES
			LOGACTIVE=YES
		fi
		if [ "$LOGACTIVE" = "NO" ]
		then
			sleep 1
		fi
		
	done
}
core_executelog() {
	while lib_check_server_running
	do 
		RECIEVEDCOMMAND=$(mysql -D $CONFIGDTSD_MYSQLDB -u $CONFIGDTSD_MYSQLUSER -p$CONFIGDTSD_MYSQLPASS -sNe "select COMMAND from COMMANDDB order by line asc limit 1;")
		if [ -z "$RECIEVEDCOMMAND" ]
		then
			EXECTUTEACTIVE=NO
		else
			EXECTUTEACTIVE=YES
			RECIEVEDPARAMETER=$(mysql -D $CONFIGDTSD_MYSQLDB -u $CONFIGDTSD_MYSQLUSER -p$CONFIGDTSD_MYSQLPASS -sNe "select PARAMETER from COMMANDDB order by line asc limit 1;")
			#echo "$RECIEVEDCOMMAND $RECIEVEDPARAMETER"
			CURRENTARRAY=($RECIEVEDPARAMETER)
			unset CURRENTARRAY[0]
			unset CURRENTARRAY[1]
			FORMATEDPARAMETER=${CURRENTARRAY[@]}
			
			eval $RECIEVEDCOMMAND '$FORMATEDPARAMETER'
			mysql -D $CONFIGDTSD_MYSQLDB -u $CONFIGDTSD_MYSQLUSER -p$CONFIGDTSD_MYSQLPASS -e "DELETE FROM COMMANDDB order by line asc limit 1;"
			
		fi
		if [ "$EXECTUTEACTIVE" = "NO" ]
		then
			sleep 1
		fi
	done
}
core_makesearchdb() {
# Make the search database which contains all the search strings and their related functions
	log_myerasetable SEARCHDB
	SEARCHVAR=( $(compgen -v | grep LOGSEARCH_ ) )
	SEARCHARRAY=0
	while [ -n "${SEARCHVAR[$SEARCHARRAY]+set}" ]
	do
		CURRENTSEARCH=${SEARCHVAR[$SEARCHARRAY]}
		CURRENTSEARCHSTRING=${!CURRENTSEARCH}
		CURRENTSEARCHFUNCTION=${CURRENTSEARCH#*_}
		lib_myinsert SEARCHDB SEARCHFUNCTION "$CURRENTSEARCHFUNCTION"
		lib_myupdate SEARCHDB SEARCHSTRING "$CURRENTSEARCHSTRING" SEARCHFUNCTION $CURRENTSEARCHFUNCTION
		let SEARCHARRAY++
	done
}

 
