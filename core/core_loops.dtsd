#!/bin/bash
# Shadow .01 Based off of DTSD
# Script that follows the log and feeds the log into the search functions and database

MYSQLDTSD_LOGLOOP_LOGSTRING="TEXT NOT NULL"
MYSQLDTSD_SEARCHDB_SEARCHSTRING="VARCHAR(255)"
#MYSQLALTER_SEARCHDB_SEARCHSTRING="UNIQUE INDEX"
MYSQLDTSD_SEARCHDB_SEARCHFUNCTION="VARCHAR(25)"
MYSQLDTSD_SEARCHRESULT_RESULTSTRING="TEXT NOT NULL"
MYSQLDTSD_SEARCHRESULT_RESULTFUNCTION="TEXT NOT NULL"

# The current logging script works by feeding the current starmade log into the database and then searching the database to find matches with search
# strings and their associated functions
ONSTART_RUN() {
	lib_screensend $CONFIGDTSD_DTSDSCREEN $CONFIGDTSD_SCRIPTPATH mycreate
	lib_screensend $CONFIGDTSD_DTSDSCREEN $CONFIGDTSD_SCRIPTPATH setranks
	lib_screensend $CONFIGDTSD_DTSDSCREEN $CONFIGDTSD_SCRIPTPATH makesearchdb
	lib_screensendback $CONFIGDTSD_DTSDSCREEN $CONFIGDTSD_SCRIPTPATH logloop
	lib_screensendback $CONFIGDTSD_DTSDSCREEN $CONFIGDTSD_SCRIPTPATH resultloop
	echo "On start executed"
}

ONINTERVAL_60_announce() {
	lib_screensend $CONFIGDTSD_MAINSCREEN "/chat Welcome to the server"
}

ONEND_goodbye() {
echo "Server stopped"

}
core_mainloop() {
    ONSTART=( $(compgen -A function | grep ONSTART_) )
    ONINTERVAL=( $(compgen -A function | grep ONINTERVAL_) )
    ONEND=( $(compgen -A function | grep ONEND_) )
    for func in ${ONSTART[@]}
    do
        $func &
    done
    curtime=0
	while ! lib_check_server_running
	do
        for func in ${ONINTERVAL[@]}
        do
#			echo "Checking on interval functions"
			#the % operator returns the remainder of a division. when this remainder is 0, that means the time is a while multiple of the interval
            #meaning the function should be ran
            if [ $(( curtime%$(($(echo $func | cut -d"_" -f2)*10)))) -eq 0 ]
            then
#			echo "executing interval function"
				$func &
            fi
        done
        let curtime++
#		echo "started loop"
# A tiny sleep to prevent cpu burning overhead
		sleep 0.1
# Uses Cat to calculate the number of lines in the log file
	done
    for func in ${ONEND[@]}
    do
        $func &
    done
}

core_makesearchdb() {
# Make the search database whish contains all the search strings and their related functions
	log_myerasetable SEARCHDB
	SEARCHVAR=( $(compgen -v | grep LOGSEARCH_ ) )
	SEARCHARRAY=0
	while [ -n "${SEARCHVAR[$SEARCHARRAY]+set}" ]
	do
		CURRENTSEARCH=${SEARCHVAR[$SEARCHARRAY]}
		CURRENTSEARCHSTRING=${!CURRENTSEARCH}
		CURRENTSEARCHFUNCTION=${CURRENTSEARCH#*_}
		lib_myinsert SEARCHDB SEARCHFUNCTION "$CURRENTSEARCHFUNCTION"
		lib_myupdate SEARCHDB SEARCHSTRING "$CURRENTSEARCHSTRING" SEARCHFUNCTION $CURRENTSEARCHFUNCTION
		let SEARCHARRAY++
	done
}

core_logloop() {
# This function is testing a solution to the sluggishness of the current_core loop.  Currently it inserts lines into the database while they are received from a log file.
	log_myerasetable LOGLOOP
	log_myerasetable SEARCHRESULT
	testloop=0
	LINEARRAY=0
 while true
	do 
	NUMOFLINES=$(wc -l $CONFIGDTSD_INSTALLPATH/StarMade/logs/log.txt.0 | cut -d" " -f1)
# In case Linestart does not have a value give it an interger value of 1.  The prevents a startup error on the script.
	if [ -z "$LINESTART" ]
		then
			LINESTART=$NUMOFLINES
#			echo "Start at line $LINESTART"
		fi
# If the number of lines read from the log file is greater than last line read + 1 from the log then feed more lines.
		if [ "$NUMOFLINES" -gt "$LINESTART" ] 
		then
#	        echo "$NUMOFLINES is the total lines of the log"
#    	    echo "$LINESTART is linestart"
			let LINESTART++
# Use sed to gather the current selection of lines
			sed -n "$LINESTART,$NUMOFLINES p" $CONFIGDTSD_INSTALLPATH/StarMade/logs/log.txt.0 > $CONFIGDTSD_INSTALLPATH/SEDSELECT.txt
# Remove all occurrences of quotes with a in-line edit 
			sed -i 's/\"//g' $CONFIGDTSD_INSTALLPATH/SEDSELECT.txt
# Surround every line with a quote for Mysql data entry
			awk '{ print "\""$0"\""}' $CONFIGDTSD_INSTALLPATH/SEDSELECT.txt > $CONFIGDTSD_INSTALLPATH/MYSQLFORMAT.txt
# Replace all new lines with a left bracket for lines terminated setting in mysqlimport.  Since the log does not use this character and neither does Mysql it seems to work for now.
			awk '{printf("%s{",$0)}' $CONFIGDTSD_INSTALLPATH/MYSQLFORMAT.txt > $CONFIGDTSD_INSTALLPATH/LOGLOOP.txt	
			mysqlimport \
			--user=$CONFIGDTSD_MYSQLUSER \
			--password=$CONFIGDTSD_MYSQLPASS \
			--columns=LOGSTRING \
			--fields-enclosed-by='"' \
			--lines-terminated-by='{' \
			--silent \
			--local \
			dtsddb $CONFIGDTSD_INSTALLPATH/LOGLOOP.txt
#			select LOGSTRING from LOGLOOP inner join SEARCHDB on locate(SEARCHSTRING, LOGSTRING) > 0
			mysql -D $CONFIGDTSD_MYSQLDB -u $CONFIGDTSD_MYSQLUSER -p$CONFIGDTSD_MYSQLPASS -e  "INSERT INTO SEARCHRESULT (RESULTSTRING, RESULTFUNCTION) SELECT LOGLOOP.LOGSTRING, SEARCHDB.SEARCHFUNCTION FROM LOGLOOP, SEARCHDB WHERE LOCATE(SEARCHDB.SEARCHSTRING, LOGLOOP.LOGSTRING) >0"
			log_myerasetable LOGLOOP		
			LINESTART=$NUMOFLINES
		fi
done		
}

core_resultloop() {
# The result loop goes through the search results database line by line starting with the last entry
	while true
	do
# Get the last line number of the search database
		LASTLINESEARCH=$(mysql -D $CONFIGDTSD_MYSQLDB -u $CONFIGDTSD_MYSQLUSER -p$CONFIGDTSD_MYSQLPASS -sNe "SELECT line FROM SEARCHRESULT ORDER BY line DESC LIMIT 1;")
# Make sure line has a value if not the script effectively waits for searchresults to exist
		if [ -n "$LASTLINESEARCH" ]
			then
#			echo $LASTLINESEARCH
# Set linesearch to the most recent line if it doesn't exist yet
			if [ -z "$LINESSEARCHSTART" ]
			then
				LINESSEARCHSTART=$LASTLINESEARCH
#				echo "Start at line $LINESSEARCHSTART"
			fi	
			if [ "$LASTLINESEARCH" -gt "$LINESSEARCHSTART" ] 
			then
				echo "Line is greater"
# Get the current search string from the DB
				COMMANDSEARCHSTRING=$(mysql -D $CONFIGDTSD_MYSQLDB -u $CONFIGDTSD_MYSQLUSER -p$CONFIGDTSD_MYSQLPASS -sNe "select RESULTSTRING from SEARCHRESULT where line='$LINESSEARCHSTART'")
				echo $COMMANDSEARCHSTRING
# Get the current search function from the DB			
				COMMANDFUNCTION=$(mysql -D $CONFIGDTSD_MYSQLDB -u $CONFIGDTSD_MYSQLUSER -p$CONFIGDTSD_MYSQLPASS -sNe "select RESULTFUNCTION from SEARCHRESULT where line='$LINESSEARCHSTART'")
				echo $COMMANDFUNCTION
				if [ -n "$COMMANDSEARCHSTRING" ] && [ -n "$COMMANDFUNCTION" ]
				then
					eval $COMMANDFUNCTION '$COMMANDSEARCHSTRING' &
				fi
			let LINESSEARCHSTART++
			fi
		fi	
	done

}

log_mysql_dtsd() {
    MYLOGDUMPCOMMAND="${@:1}"
    lib_myinsert DTSDLOG LOGSTRING $MYLOGDUMPCOMMAND
}

 