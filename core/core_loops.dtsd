#!/bin/bash
# Shadow .01 Based off of DTSD
# Script that follows the log and feeds the log into the search functions and database

MYSQLDTSD_DTSDLOG_LOGSTRING=TEXT
MYSQLDTSD_DTSDLOG_LOGDATE=TIMESTAMP
MYSQLDTSD_TESTLOG_LOGSTRING="TEXT NOT NULL"
MYSQLDTSD_SEARCHDB_SEARCHSTRING="TEXT NOT NULL"
MYSQLDTSD_SEARCHDB_SEARCHFUNCTION="VARCHAR(25)"

# Test logging script.  This function goes through the log from script by following the number of lines the log has and then
# loading new lines as they are read into an array.  This array is fed into lib_searchline which will match it to any functions
# that need returns from the log
core_mainloop() {
	testloop=0
	LINEARRAY=0
    ONSTART=( $(compgen -A function | grep ONSTART_) )
    ONINTERVAL=( $(compgen -A function | grep ONINTERVAL_) )
    ONEND=( $(compgen -A function | grep ONEND_) )
    for func in ${ONSTART[@]}
    do
        $func &
    done
    curtime=0
	while ! lib_check_server_running
	do
        for func in ${ONINTERVAL[@]}
        do
            #the % operator returns the remainder of a division. when this remainder is 0, that means the time is a while multiple of the interval
            #meaning the function should be ran
            if [ $(( curtime%$(($(echo $func | cut -d"_" -f2)*10)))) -eq 0 ]
            then
                $func &
            fi
        done
        let curtime++
#		echo "started loop"
# A tiny sleep to prevent cpu burning overhead
		sleep 0.1
# Uses Cat to calculate the number of lines in the log file
		NUMOFLINES=$(wc -l $CONFIGDTSD_INSTALLPATH/CONFIGDTSD_MAINSCREEN.log | cut -d" " -f1)
# In case Linestart does not have a value give it an interger value of 1.  The prevents a startup error on the script.
		if [ -z "$LINESTART" ]
		then
			LINESTART=$NUMOFLINES
#			echo "Start at line $LINESTART"
		fi
# If the number of lines read from the log file is greater than last line read + 1 from the log then feed more lines.
		if [ "$NUMOFLINES" -gt "$LINESTART" ] 
		then
#	        echo "$NUMOFLINES is the total lines of the log"
#    	    echo "$LINESTART is linestart"
			let LINESTART++
			OLD_IFS=$IFS
# This sets the field seperator to use \n next line instead of next space.  This makes it so the array is a whole sentence not a word
			IFS=$'\n'
# Linestring is stored as an array of every line in the log
			LINESTRING=( $(awk "NR==$LINESTART, NR==$NUMOFLINES" $CONFIGDTSD_INSTALLPATH/CONFIGDTSD_MAINSCREEN.log) )
			IFS=$OLD_IFS
			LINESTART=$NUMOFLINES
#			echo "$LINESTART is adjusted linestart"
		else
			LINESTRING=()
		fi
		LINENUMBER=0
		while [ -n "${LINESTRING[$LINENUMBER]+set}" ] 
		do
#			echo "Current Line in Array $LINENUMBER"
			CURRENTSTRING=${LINESTRING[$LINENUMBER]}
# Add the search string function here
# Are we sure backgrounding lib_searchline is the behaviour we want?
			lib_searchline $CURRENTSTRING &
# Temporary solution to fixing mysql errors because of quotes
			CURRENTSTRING=${CURRENTSTRING/\"/}
			CURRENTSTRING=${CURRENTSTRING/\"/}
			log_mysql_dtsd $CURRENTSTRING &
			let LINENUMBER++
		done
	done
    for func in ${ONEND[@]}
    do
        $func &
    done
}

core_makesearchdb() {
	log_myerasetable SEARCHDB
	SEARCHVAR=( $(compgen -v | grep LOGSEARCH_ ) )
	SEARCHARRAY=0
	while [ -n "${SEARCHVAR[$SEARCHARRAY]+set}" ]
	do
		
		CURRENTSEARCH=${SEARCHVAR[$SEARCHARRAY]}
		CURRENTSEARCHSTRING=${!CURRENTSEARCH}
		CURRENTSEARCHFUNCTION=${CURRENTSEARCH#*_}
		lib_myinsert SEARCHDB SEARCHFUNCTION "$CURRENTSEARCHFUNCTION"
		lib_myupdate SEARCHDB SEARCHSTRING "$CURRENTSEARCHSTRING" SEARCHFUNCTION $CURRENTSEARCHFUNCTION
#	echo "Search function is $SEARCHFUNCTION"
#	echo "Search string is ${!CURRENTSEARCH}"
		let SEARCHARRAY++
	done
}

core_testloop() {
# This function is testing a solution to the sluggishness of the current_core loop.  Currently it inserts lines into the database while they are received from a log file.
	log_myerasetable TESTLOG
	testloop=0
	LINEARRAY=0
 while true
	do 
	NUMOFLINES=$(wc -l $CONFIGDTSD_INSTALLPATH/StarMade/logs/log.txt.0 | cut -d" " -f1)
# In case Linestart does not have a value give it an interger value of 1.  The prevents a startup error on the script.
	if [ -z "$LINESTART" ]
		then
			LINESTART=$NUMOFLINES
#			echo "Start at line $LINESTART"
		fi
# If the number of lines read from the log file is greater than last line read + 1 from the log then feed more lines.
		if [ "$NUMOFLINES" -gt "$LINESTART" ] 
		then
#	        echo "$NUMOFLINES is the total lines of the log"
#    	    echo "$LINESTART is linestart"
			let LINESTART++
# Use sed to gather the current selection of lines
			sed -n "$LINESTART,$NUMOFLINES p" $CONFIGDTSD_INSTALLPATH/StarMade/logs/log.txt.0 > $CONFIGDTSD_INSTALLPATH/SEDSELECT.txt
# Remove all occurrences of quotes with a in-line edit 
			sed -i 's/\"//g' $CONFIGDTSD_INSTALLPATH/SEDSELECT.txt
# Surround every line with a quote for Mysql data entry
			awk '{ print "\""$0"\""}' $CONFIGDTSD_INSTALLPATH/SEDSELECT.txt > $CONFIGDTSD_INSTALLPATH/MYSQLFORMAT.txt
# Replace all new lines with a left bracket for lines terminated setting in mysqlimport.  Since the log does not use this character and neither does Mysql it seems to work for now.
			awk '{printf("%s{",$0)}' $CONFIGDTSD_INSTALLPATH/MYSQLFORMAT.txt > $CONFIGDTSD_INSTALLPATH/TESTLOG.txt	



			
			# Surround every line with a quote for Mysql data entry
#			awk '{ print "\""$0"\""}' $CONFIGDTSD_INSTALLPATH/SEDSELECT.txt > $CONFIGDTSD_INSTALLPATH/MYSQLFORMAT.txt
#			 sed 's/^.*$/"&"/g' $CONFIGDTSD_INSTALLPATH/MYSQLFORMAT.txt
#			cat $CONFIGDTSD_INSTALLPATH/MYSQLFORMAT.txt
# Replace all new lines with a left bracket for lines terminated setting
#			awk '{printf("%s{",$0)}' $CONFIGDTSD_INSTALLPATH/MYSQLFORMAT.txt > $CONFIGDTSD_INSTALLPATH/TESTLOG.txt
#
#			sed -n "$LINESTART,$NUMOFLINES p" $CONFIGDTSD_INSTALLPATH/CONFIGDTSD_MAINSCREEN.log >> sedoutput.txt		
			mysqlimport \
			--user=$CONFIGDTSD_MYSQLUSER \
			--password=$CONFIGDTSD_MYSQLPASS \
			--columns=LOGSTRING \
			--fields-enclosed-by='"' \
			--lines-terminated-by='{' \
			--local \
			dtsddb $CONFIGDTSD_INSTALLPATH/TESTLOG.txt
			LINESTART=$NUMOFLINES
		fi
done		
}



log_mysql_dtsd() {
    MYLOGDUMPCOMMAND="${@:1}"
    lib_myinsert DTSDLOG LOGSTRING $MYLOGDUMPCOMMAND
}
